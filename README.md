<img src="https://github.com/unnoon/cell-type/raw/master/rsc/img/cell-type.png">

[![Build Status](https://travis-ci.org/unnoon/cell-type.svg?branch=dev)](http://inch-ci.org/github/unnoon/cell-type)
[![Coverage Status](https://coveralls.io/repos/github/unnoon/cell-type/badge.svg?branch=dev)](https://coveralls.io/github/unnoon/cell-type?branch=dev)
[![Inline docs](http://inch-ci.org/github/unnoon/cell-type.svg?branch=dev)](http://inch-ci.org/github/unnoon/cell-type)
[![MIT license](http://img.shields.io/badge/license-MIT-brightgreen.svg)](http://opensource.org/licenses/MIT)

Prototypal(OLOO) inheritance algorithm.

## Features

- Fully tested
- Fully documented
- OLOO ready
- Static & getter/setter inheritance
- Dynamic prototype & property swapping
- Supports symbols
- Validations for overrides, static this usage, illegal private usage
- Supports attributes! i.e. frozen, static, const etc.
- Supports amd, node, globals, es6 modules
- ES6 & ES5 binaries (as well as intermediate version)
- Made with bits of love!

## Installation

[bower](http://bower.io)

`bower install cell-type`

[npm](https://www.npmjs.com)

`npm install cell-type`

## Usage

```js
const Beginner = Type({properties: {
    init(skill)
    {
        this._x = 0;

        this.skills = ['html'];
        if(skill) {this.skills.push(skill)}

        return this
    },
    stringify()
    {
        return 'beginner'
    },
    get x()
    {
        return this._x - 1
    },
    set x(val)
    {
        return this._x = val + 2
    },
    staticMethod() {
    "<$attrs static>";  // attributes can be used to supply additional functionality
    {
        return 'iamstatic'
    }}
}});

const Specialist = Type({links: Beginner, properties: {
    init(skill)
    {
        this._upper(skill);
        this.skills.push('css');

        return this
    }
}});
// using the new keyword is also possible
const Expert = new Type({name: 'Expert', links: Specialist, properties: { // an additional name can be supplied for debugging purposes
    init(skill)
    {
        this._x = 7;

        this._upper(skill);
        this.skills.push('js');

        return this
    },
    stringify()
    {
        return 'expert'
    },
    get x()
    {
        return this._upper() - 3
    },
    set x(val)
    {
        this._x = this._upper(val) + 4
    },
    staticMethod() {
    "<$attrs static enumerable !configurable>";  // attributes can be used to supply additional functionality
    {
        return this._upper()
    }},
    staticProp: {[$attrs]: 'static', value: 10}
}});

const e1 = Object.create(Expert).init('xhtml');

// default inheritance features
expect(e1.skills).to.eql(["html", "xhtml", "css", "js"]);
expect(Beginner.isPrototypeOf(e1)).to.be.true;
expect(Specialist.isPrototypeOf(e1)).to.be.true;
expect(Expert.isPrototypeOf(e1)).to.be.true;

// inheritance for getters/setters
e1.x = 4;
expect(e1._x).to.deep.equal(10);
expect(e1.x).to.deep.equal(6);

// inheritance of static methods
expect(Expert.staticMethod()).to.eql('iamstatic');

// wrapping of static properties
e2 = Object.create(Expert);
e1.staticProp = 20;
expect(e1.staticProp).to.eql(20);
expect(e2.staticProp).to.eql(20);

// using attributes to supply additional functionality
expect(Object.getOwnPropertyDescriptor(Expert, 'init').enumerable).to.be.false; // by default enumerable is set to false
expect(Object.getOwnPropertyDescriptor(Expert, 'init').configurable).to.be.true; // by default configurable is set to true
expect(Object.getOwnPropertyDescriptor(Expert, 'staticMethod').enumerable).to.be.true; // using attributes this can be changed
expect(Object.getOwnPropertyDescriptor(Expert, 'staticMethod').configurable).to.be.false; // using attributes this can be changed

// validations
expect(console.warn.calledWith("[Expert]: No overriding attribute and not calling upper in overriding (value) property 'stringify'.")).to.be.true;
```

For more usage example see the unit tests @ /test/unit/Type-spec.js

## Prototypal(OLOO) inheritance

By default prototypal(OLOO) inheritance is supported. Practically this means that types('classes') created by Type will just be simple objects that can be used as a prototype (no constructor function is supplied). In general I like to avoid any class related jargon. Therefore this._upper (instead of this._super) can be used to access a property higher up in the prototype chain. Statics will be directly available on the prototype. Static properties will be wrapped in a getter/setter so the value can be changed from this. 

## Documentation

Documentation can be generated by running the command below and is outputted @ /doc.

`npm run docs`

Make sure you'll run a npm install first.

## Future work

- Traits (coming up in the near future)
- State properties
- Dependency injection (in some form or another)


